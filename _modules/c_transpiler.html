

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>c_transpiler &mdash; tidowa  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> tidowa
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../start.html">First steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#discretization">Discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#code-generation">Code Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#compilation">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#execution">Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html#first-steps">First steps</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">tidowa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>c_transpiler</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for c_transpiler</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">src.codegen.TemplateTranspiler</span> <span class="k">import</span> <span class="n">TemplateTranspiler</span>
<span class="kn">from</span> <span class="nn">src.codegen.EquationTranspiler</span> <span class="k">import</span> <span class="n">CBased_EquationTranspiler</span>
<span class="kn">from</span> <span class="nn">src.utils.print_utils</span> <span class="k">import</span> <span class="n">copy_file_to</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">sympy.codegen.ast</span> <span class="k">import</span> <span class="n">While</span>
<span class="kn">from</span> <span class="nn">src.codegen.Transpiler</span> <span class="k">import</span> <span class="n">Transpiler</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains the functionality to translate discretized sympy equations into corresponding C code</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Simple_C_Transpiler"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler">[docs]</a><span class="k">class</span> <span class="nc">Simple_C_Transpiler</span><span class="p">(</span><span class="n">Transpiler</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpiler that generates C-Code for numerical integration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Simple_C_Transpiler.generate"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate C-Code based on the information provided by the discretization stage.</span>

<span class="sd">        This function implements the generation of C-Code based on the information provided by the discretization stage.</span>
<span class="sd">        The algorithm to write the code is implemented in the file c_transpiler2.py, which this function calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_directory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simple_C_Transpiler.generate_loop"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler.generate_loop">[docs]</a>    <span class="k">def</span> <span class="nf">generate_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_eq</span><span class="p">,</span> <span class="n">loop_type</span><span class="p">,</span> <span class="n">loop_iterations</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dummy function that implements the abstract parent function in Transpiler.</span>

<span class="sd">        Not implemented yet, as extending this transpiler for loops would be unneccessarily complicated. Use the other C-Transpiler instead!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not implemented yet! Error!&quot;</span><span class="p">)</span></div>


    <span class="n">output_digits</span> <span class="o">=</span> <span class="mi">12</span>


<div class="viewcode-block" id="Simple_C_Transpiler.main"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler.main">[docs]</a>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_directory</span><span class="p">,</span> <span class="n">data_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate C-Code based on the information provided by the discretization stage.</span>

<span class="sd">        Args:</span>
<span class="sd">            output_directory (str): directory where the integration results are printed.</span>
<span class="sd">            data_type (str): float / double etc. Not used by this transpiler at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- HEAD ---</span>
        <span class="c1"># append #include &lt;time.h&gt; to measure time</span>
        <span class="n">ccode</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;#include &lt;stdio.h&gt;</span>
<span class="s1">    #include &lt;math.h&gt;</span>
<span class="s1">    #include &quot;calculation.h&quot;</span>
<span class="s1">    #include &lt;time.h&gt;</span>
<span class="s1">    #include &lt;stdlib.h&gt;</span><span class="se">\n</span><span class="s1"></span>
<span class="s1">    &#39;&#39;&#39;</span>

        <span class="c1"># --- FUNCTION calc_values ---</span>

        <span class="c1"># --- FUNCHEAD ---</span>
        <span class="n">str_func_head</span> <span class="o">=</span> <span class="s2">&quot;void calc_values ( double* initialvalues, double* paramvalues, int issuenum, double deltaT, int nsteps){</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_func_head</span>
        <span class="c1"># --- FUNCHEAD ---</span>

        <span class="c1"># --- FUNCBODY ---</span>
        <span class="c1"># Stream for csv formated output</span>
        <span class="n">str_stream</span> <span class="o">=</span> <span class="s2">&quot;/*opening the output stream in appending mode*/</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">str_stream</span> <span class="o">+=</span> <span class="s2">&quot;char outputpath[128];</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">str_stream</span> <span class="o">+=</span> <span class="s2">&quot;snprintf(outputpath, 128, </span><span class="se">\&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">output_directory</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;/&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">output_directory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">output_directory</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># Adds a / if it is missing at the end of output_directory</span>
        <span class="n">str_stream</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">_data.csv</span><span class="se">\&quot;</span><span class="s2">, issuenum);   //this corresponds to output_path in Transpiler object</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">str_stream</span> <span class="o">+=</span> <span class="s2">&quot;FILE *csv_output = fopen(outputpath, </span><span class="se">\&quot;</span><span class="s2">a</span><span class="se">\&quot;</span><span class="s2">);</span><span class="se">\n\n\t</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_stream</span>

        <span class="c1"># Local variables for variable and parameter values</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str_locvars = &quot;/*allocating value arrays*/\n\t&quot;</span>
<span class="sd">        for var in self.rec.variablelookuptable:</span>
<span class="sd">            str_locvars += &quot;double %s_values[%d];\n\t&quot; % (var, nsteps)</span>
<span class="sd">        str_locvars += &quot;/*assigning initialvalues*/\n\t&quot;</span>
<span class="sd">        for i in range(len(self.rec.variablelookuptable)):</span>
<span class="sd">            str_locvars += &quot;%s_values[0] = initialvalues[%d];\n\t&quot; % (self.rec.variablelookuptable[i], i)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">str_locvars</span> <span class="o">=</span> <span class="s2">&quot;/*assigning paramvalues*/</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">parameterlookuptable</span><span class="p">)):</span>
            <span class="n">str_locvars</span> <span class="o">+=</span> <span class="s2">&quot;double </span><span class="si">%s</span><span class="s2"> = paramvalues[</span><span class="si">%i</span><span class="s2">];</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">parameterlookuptable</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># TODO add t0</span>
        <span class="n">str_locvars</span> <span class="o">+=</span> <span class="s2">&quot;double t = 0;</span><span class="se">\n\t</span><span class="s2">&quot;</span>

        <span class="c1"># Set up a local variable for every RungeKutta Stage, avoid double declaration</span>
        <span class="c1"># Create the list of all equation.lhs</span>
        <span class="n">equality_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">disc_equations</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Equality</span><span class="p">)]</span>
        <span class="n">while_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">disc_equations</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">codegen</span><span class="o">.</span><span class="n">ast</span><span class="o">.</span><span class="n">While</span><span class="p">)]</span>
        <span class="n">while_equality_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">while_list</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">_sorted_args</span><span class="p">]</span>

        <span class="n">lhs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">equality_list</span><span class="p">))</span>
        <span class="n">lhs_list</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">while_equality_list</span><span class="p">))</span>
        <span class="c1"># Eliminate duplicates</span>
        <span class="n">lhs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">))</span>
        <span class="c1"># Write declarations to the ccode</span>
        <span class="k">for</span> <span class="n">curr_lhs</span> <span class="ow">in</span> <span class="n">lhs_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">curr_lhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="p">):</span>
                <span class="n">str_locvars</span> <span class="o">+=</span> <span class="s2">&quot;double </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">curr_lhs</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_locvars</span>

        <span class="c1"># Set up a local variable for every entry in timestep_specific_variables</span>
        <span class="c1"># Any variable with timestep offset 0 will be initialised with the corresponding initialvalue</span>
        <span class="n">str_disc_variable</span> <span class="o">=</span> <span class="s2">&quot;/*declaring dependent variables*/</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">curr_var</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Case var_n (timestep offset 0)</span>
            <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">str_disc_variable</span> <span class="o">+=</span> <span class="s2">&quot;double </span><span class="si">%s</span><span class="s2"> = initialvalues[</span><span class="si">%d</span><span class="s2">];</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">curr_var</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Case var_nplus1 (timestep offset != 0)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">str_disc_variable</span> <span class="o">+=</span> <span class="s2">&quot;double </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n\t</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">curr_var</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_disc_variable</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span>

        <span class="c1"># Headline and initialvalues into the output csv file</span>
        <span class="n">str_firstprint</span> <span class="o">=</span> <span class="s2">&quot;/*writing the first lines into the output csv file*/</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;fprintf(csv_output, </span><span class="se">\&quot;</span><span class="s2">t&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">variablelookuptable</span><span class="p">:</span>
            <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">var</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\&quot;</span><span class="s2">);</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;fprintf(csv_output, </span><span class="se">\&quot;</span><span class="si">%e</span><span class="s2">&quot;</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%e</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">variablelookuptable</span><span class="p">)</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\&quot;</span><span class="s2"> , 0*deltaT&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">variablelookuptable</span><span class="p">)):</span>
            <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;, initialvalues[</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="n">str_firstprint</span> <span class="o">+=</span> <span class="s2">&quot;);</span><span class="se">\n\n\t</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_firstprint</span>

        <span class="c1"># TIME MEASUREMENT</span>
        <span class="n">time_stuff</span> <span class="o">=</span> <span class="s2">&quot;struct timespec before, after;</span><span class="se">\n\t</span><span class="s2">clock_gettime(CLOCK_REALTIME, &amp;before);</span><span class="se">\n\n\t</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">time_stuff</span>

        <span class="c1"># Main loop for calculating the variable values</span>
        <span class="n">str_mainloop</span> <span class="o">=</span> <span class="s2">&quot;/*calculating the values iteratively*/</span><span class="se">\n\t</span><span class="s2">&quot;</span>

        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;for (int step = 1; step&lt;nsteps; step++){</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>
        <span class="c1"># update variable values</span>
        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">disc_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">curr_eq</span><span class="p">)</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">codegen</span><span class="o">.</span><span class="n">ast</span><span class="o">.</span><span class="n">While</span><span class="p">:</span>
                <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_loop</span><span class="p">(</span><span class="n">curr_eq</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># LHS - by construction only a single symbol, representing a timestep_specific_variable,</span>
            <span class="c1"># a parameter or a RungeKutta stage</span>
            <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = &quot;</span> <span class="o">%</span> <span class="n">curr_eq</span><span class="o">.</span><span class="n">lhs</span>

            <span class="c1"># RHS</span>
            <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>

        <span class="c1"># Writing the results to an ouput CSV-file</span>
        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;/*writing the new calculated values into the output csv file*/</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>
        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;fprintf(csv_output, </span><span class="se">\&quot;</span><span class="si">%e</span><span class="s2">&quot;</span>
        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot; %.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_digits</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">variablelookuptable</span><span class="p">)</span>
        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\&quot;</span><span class="s2"> , (step)*deltaT&quot;</span>
        <span class="c1"># write the timestep_specific_variables (with timestep offset 1) in the correct order</span>
        <span class="c1"># THIS ASSUMES THAT THE ORDER OF timestep_specific_variables is still the same as at its initialisation in the discretization stage (given in python 3.6 and higher)</span>
        <span class="k">for</span> <span class="n">curr_var</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Case timestep offset = 1</span>
            <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">curr_var</span>
            <span class="c1"># Case timestep offset = 0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;);</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>
        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;t += deltaT;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>

        <span class="c1"># Overwrite the var_n with the values of var_nplus1 for the start of the next iteration</span>
        <span class="c1"># THIS ASSUMES THAT THE ORDER OF timestep_specific_variables is still the same as at its initialisation in the discretization stage (given in python 3.6 and higher)</span>
        <span class="k">for</span> <span class="n">curr_var</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Case timestep offset = 0, should be the case for every first element</span>
            <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = &quot;</span> <span class="o">%</span> <span class="n">curr_var</span>
            <span class="c1"># Case timestep offset = 1, should be the case for every second element</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">curr_var</span>

        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span>

        <span class="n">str_mainloop</span> <span class="o">+=</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">str_mainloop</span>

        <span class="c1"># TIME MEASUREMENT</span>
        <span class="n">time_stuff</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">clock_gettime(CLOCK_REALTIME, &amp;after);</span><span class="se">\n\t</span><span class="s2">double seconds = (double)((after.tv_sec+after.tv_nsec*1e-9) - (double)(before.tv_sec+before.tv_nsec*1e-9));</span><span class="se">\n\t</span><span class="s2">FILE *time_output = fopen(</span><span class="se">\&quot;</span><span class="s2">../time_output.txt</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">a</span><span class="se">\&quot;</span><span class="s2">);</span><span class="se">\n\t</span><span class="s2">fprintf(time_output, </span><span class="se">\&quot;</span><span class="si">%e</span><span class="se">\\</span><span class="s2">n</span><span class="se">\&quot;</span><span class="s2">, seconds);</span><span class="se">\n\t</span><span class="s2">fclose(time_output);</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="n">time_stuff</span>

        <span class="c1"># Closing the stream for csv output file</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="s2">&quot;fclose(csv_output);</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1"># --- FUNCBODY ---</span>

        <span class="c1"># Closing last paranthesis</span>
        <span class="n">ccode</span> <span class="o">+=</span> <span class="s2">&quot;}&quot;</span>
        <span class="c1"># --- FUNCTION calc_values ---</span>

        <span class="c1"># create a new file and write the C code there</span>
        <span class="n">codegen_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
        <span class="n">rel_path</span> <span class="o">=</span> <span class="s2">&quot;../exec/ccode/calc_func.c&quot;</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">codegen_dir</span><span class="p">,</span> <span class="n">rel_path</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ccode</span><span class="p">)</span></div>

        <span class="c1"># -- END OF c_transpiler.main() --</span>


    <span class="c1"># ASSUMPTION: The only variables left in the equation are the x_i_n</span>
    <span class="c1"># @param:</span>
    <span class="c1"># @expr: The sympy expression to translate into C syntax</span>
    <span class="c1"># @Returns: A string in C syntax, which is equivalent to @expr</span>
<div class="viewcode-block" id="Simple_C_Transpiler.inorder"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler.inorder">[docs]</a>    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">expr_func</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span>

        <span class="c1">############### CURRENT NODE EVALUATION ##################</span>

        <span class="c1"># -- These special cases have to be evaluated in another order than inorder --</span>
        <span class="c1"># special case Pow</span>
        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span>  <span class="c1"># left child             #right child</span>
            <span class="k">return</span> <span class="s1">&#39;pow(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">))</span>
        <span class="c1"># special case exp()</span>
        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;exp(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">))</span>
                <span class="c1"># return self.inorder(sp.Pow((1 + expr.args[0] / 256), 256), data_type, vectorize)#e^a = lambda exp: sp.Pow((1 + a / 256), 256)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;exp(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">))</span>
        <span class="c1"># special case log</span>
        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;log(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Abs</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;fabs(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">))</span>
        <span class="c1"># special case Symbol    -   only possibilities should be t or an x_i</span>
        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">:</span>
            <span class="c1"># case t is a variable in the equation</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;deltaT*step&#39;</span>
            <span class="c1"># case it is a timestep_specific_variable, a parameter or a RungeKutta stage</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="c1"># Case Piecewise (conditional function)</span>
        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Piecewise</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="c1"># Iterate over the (expr, cond)-tuples of the Piecewise</span>
            <span class="c1"># apply piecewise_fold first to flatten out recursivly packed Piecewises</span>
            <span class="n">pw</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">piecewise_fold</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">pw</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="c1"># Case last tuple; must be True as conditions must be exhaustive</span>
                <span class="k">if</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">boolalg</span><span class="o">.</span><span class="n">BooleanTrue</span><span class="p">:</span>
                    <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">)</span>

                <span class="c1"># Case any onther expression-condition tuple</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">?</span><span class="si">%s</span><span class="s1">:&#39;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">)),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">)))</span>

            <span class="c1"># Close all opened paranthesis and give back NAN if none of the conditions pertained (Function must be undefined here)</span>
            <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pw</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">currnode_str</span>

        <span class="c1"># -- If not handled by the above, evaluate in inorder --</span>
        <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Mul</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>  <span class="c1"># in parenthesis, because it can have a negative sign</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="c1"># Make number float if necessary</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s2">&quot;F&quot;</span>
            <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="c1"># Conditional Symbols</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Equality</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;==&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Unequality</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;!=&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">GreaterThan</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&gt;=&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">StrictGreaterThan</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&gt;&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">LessThan</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&lt;=&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">StrictLessThan</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&lt;&#39;</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_rational</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s2">&quot;F&quot;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">And</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;&amp;&amp;&#39;</span>
        <span class="k">elif</span> <span class="n">expr_func</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Or</span><span class="p">:</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="s1">&#39;||&#39;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Float, Rational, numbers.Half,</span>
            <span class="n">currnode_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="c1"># Make number float if necessary</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                <span class="n">currnode_str</span> <span class="o">+=</span> <span class="s2">&quot;F&quot;</span>

        <span class="c1">######################### EXPRESSION TREE TRAVERSAL #########################</span>

        <span class="c1"># case LEAF</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="n">currnode_str</span>
        <span class="c1"># case inner NODE</span>
        <span class="n">ret_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ret_str</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
            <span class="n">ret_str</span> <span class="o">+=</span> <span class="n">currnode_str</span>
        <span class="n">ret_str</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inorder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

        <span class="k">return</span> <span class="n">ret_str</span></div>


<div class="viewcode-block" id="Simple_C_Transpiler.implement_iterative_loop"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.Simple_C_Transpiler.implement_iterative_loop">[docs]</a>    <span class="k">def</span> <span class="nf">implement_iterative_loop</span><span class="p">(</span><span class="n">equation</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not implemented yet for C code! This will give an Error&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="C_Transpiler"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.C_Transpiler">[docs]</a><span class="k">class</span> <span class="nc">C_Transpiler</span><span class="p">(</span><span class="n">TemplateTranspiler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpiler that generates C-Code for numerical integration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;##&#39;</span>
    <span class="n">dir_name</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>
    <span class="n">print_results</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">template_file_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;calc_func.c&#39;</span><span class="p">:</span> <span class="s1">&#39;calc_func.c&#39;</span><span class="p">,</span> <span class="s1">&#39;calculation.h&#39;</span><span class="p">:</span> <span class="s1">&#39;calculation.h&#39;</span><span class="p">,</span> <span class="s1">&#39;main.c&#39;</span><span class="p">:</span> <span class="s1">&#39;main.c&#39;</span><span class="p">}</span>
    <span class="n">equation_transpiler_class</span> <span class="o">=</span> <span class="n">CBased_EquationTranspiler</span>

<div class="viewcode-block" id="C_Transpiler.generate_config"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.C_Transpiler.generate_config">[docs]</a>    <span class="k">def</span> <span class="nf">generate_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Final assignments</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;Final assignments</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">all_tsv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">tsv</span> <span class="ow">in</span> <span class="n">all_tsv</span><span class="p">:</span>
            <span class="c1"># For all current timestep variables -&gt; assign solutions for next timestep</span>
            <span class="k">if</span> <span class="n">tsv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">is_one_step_same_variable</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">variable</span><span class="p">:</span> <span class="n">variable</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">variable</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tsv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_one_step_same_variable</span><span class="p">,</span> <span class="n">all_tsv</span><span class="p">))</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="n">next_value</span><span class="o">.</span><span class="n">pop</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tsv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">next_value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;assignments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>

        <span class="c1"># print initial values</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;writing the first lines into the output csv file</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">fprintf(csv_output, &quot;t </span><span class="si">%s</span><span class="se">\\</span><span class="s1">n&quot;);</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">variablelookuptable</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">variable</span><span class="p">:</span> <span class="n">variable</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all_tsv</span><span class="p">))</span>
        <span class="n">string_variables</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">variables</span><span class="p">)))</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">fprintf(csv_output, &quot;</span><span class="si">%%</span><span class="s1">e </span><span class="si">%s</span><span class="se">\\</span><span class="s1">n&quot; , 0*deltaT, </span><span class="si">%s</span><span class="s1">);</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)),</span> <span class="n">string_variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;print initial values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>

        <span class="c1"># print values</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;writing the new calculated values into the output csv file</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">variable</span><span class="p">:</span> <span class="n">variable</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_tsv</span><span class="p">))</span>
        <span class="n">string_variables</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">variables</span><span class="p">)))</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">fprintf(csv_output, &quot;</span><span class="si">%%</span><span class="s1">e </span><span class="si">%s</span><span class="se">\\</span><span class="s1">n&quot; , (step)*deltaT, </span><span class="si">%s</span><span class="s1">);</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%.12e</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)),</span> <span class="n">string_variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;print values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>

        <span class="c1"># Assign parameters  (Order in lookuptable and paramvalues array are the same IF python 3.6 or newer)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;Assign parameter values</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">parameterlookuptable</span><span class="p">):</span>
            <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">double </span><span class="si">%s</span><span class="s1"> = paramvalues[</span><span class="si">%s</span><span class="s1">];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;assign parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>

        <span class="c1"># Initialize values</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;Initializing variable values</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="p">:</span>
            <span class="c1"># Initialize only current step values (not future ones)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">double </span><span class="si">%s</span><span class="s1"> = initialvalues[</span><span class="si">%s</span><span class="s1">];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">timestep_specific_variables</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;init values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span></div>

<div class="viewcode-block" id="C_Transpiler.adapt_records"><a class="viewcode-back" href="../c_transpiler.html#c_transpiler.C_Transpiler.adapt_records">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">adapt_records</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span> <span class="n">record_file</span><span class="p">):</span>
        <span class="n">copy_file_to</span><span class="p">(</span><span class="n">record_file</span><span class="p">,</span> <span class="s1">&#39;data/codegen/discrete_records/record_c.py&#39;</span><span class="p">,</span> <span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Anna Mittermair

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>