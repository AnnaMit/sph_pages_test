

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TimeIntegratorUnit &mdash; tidowa  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> tidowa
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../start.html">First steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#discretization">Discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#code-generation">Code Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#compilation">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#execution">Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html#first-steps">First steps</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">tidowa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>TimeIntegratorUnit</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for TimeIntegratorUnit</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">src.odedsl.Discretizer</span> <span class="k">import</span> <span class="n">Discretizer</span> <span class="k">as</span> <span class="n">dsc</span>


<div class="viewcode-block" id="get_default_additional_variables"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.get_default_additional_variables">[docs]</a><span class="k">def</span> <span class="nf">get_default_additional_variables</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;iterative_method&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains a class for each Time Integration Method. Each of these classes inherit from the abstract class TimeIntegratorUnit. Furthermore Operator Splitting Techniques are implemented.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="TimeIntegratorUnit"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit">[docs]</a><span class="k">class</span> <span class="nc">TimeIntegratorUnit</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This abstract class is a template for time integration Methods. This class itself cannot be instantiated. It ensures, that every Method contains a term, the timestep length and for convinience</span>
<span class="sd">    a list of all variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeIntegratorUnit.__init__"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">rhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Extract the function x_i(t) from the derivative</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="c1"># deltaT is an instance variable, so that TimeIntegratorUnits can be created for variable timestep length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;deltaT&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeIntegratorUnit.set_deltaT"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.set_deltaT">[docs]</a>    <span class="k">def</span> <span class="nf">set_deltaT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deltaT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">=</span> <span class="n">deltaT</span></div>

<div class="viewcode-block" id="TimeIntegratorUnit.get_additional_config_variables"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.get_additional_config_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_additional_config_variables</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_default_additional_variables</span><span class="p">()</span></div>

    <span class="c1"># Class variable, that states how many discretized equations the function adapt_term will add to the TimeIntegratedEquationSystem object. This could be useful for example to figure out what methods can be used in Operator Splitting techniques</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<div class="viewcode-block" id="TimeIntegratorUnit.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method; This method has to be overwritten in every subclass.</span>
<span class="sd">        Examples are listed in every subclass of TimeIntegratorUnit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A term consisting of only timestep specific variables (i.e. x_n) corresponding to ``self.term`` and the annotated method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">yield</span> <span class="kc">None</span></div>

    <span class="c1"># Convert the Annotated form of the term into the corresponding time integrated form</span>
<div class="viewcode-block" id="TimeIntegratorUnit.resolve"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.resolve">[docs]</a>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to form lhs_var_n for the integration methods. lhs_var_n is the timestep specific variable corresponding to lhs_var. That variable is used in almost every integration method.</span>

<span class="sd">        Args:</span>
<span class="sd">            ties (TimeIntegratedEquationSystem): The TimeIntegratedEquationSystem instance, with a not-finished equations parameter. Use its class function ``app`` to append the integrated Equalities for each TimeIntegratorUnit and each Equation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapt_terms</span><span class="p">(</span><span class="n">ties</span><span class="p">)</span></div>

    <span class="c1"># -- Helper methods --</span>
<div class="viewcode-block" id="TimeIntegratorUnit.get_lhs_var"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.get_lhs_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_lhs_var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lhs-var in the form x_i(t)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span></div>

<div class="viewcode-block" id="TimeIntegratorUnit.time_tendencies"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.TimeIntegratorUnit.time_tendencies">[docs]</a>    <span class="k">def</span> <span class="nf">time_tendencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Example:</span>
<span class="sd">            lambda1 * u(t) + 2      --&gt;     lambda1 * u_n + 2</span>
<span class="sd">        Returns:</span>
<span class="sd">            The Time tendencies of ``self.term.``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a copy of @self.term</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>

        <span class="c1"># Substitute every symbol in equation_rhs with the corresponding timestepspecific symbol and update @timestep_specific_variables correspondingly</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">curr_tsv</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">curr_tsv</span><span class="p">)</span>

        <span class="c1"># Substitute possible occurrences of t</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">))</span>

        <span class="c1"># return the time tendencies</span>
        <span class="k">return</span> <span class="n">term</span></div></div>


<div class="viewcode-block" id="ExplicitEuler"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.ExplicitEuler">[docs]</a><span class="k">class</span> <span class="nc">ExplicitEuler</span><span class="p">(</span><span class="n">TimeIntegratorUnit</span><span class="p">):</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="ExplicitEuler.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.ExplicitEuler.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">lhs_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lhs_var</span><span class="p">()</span>
        <span class="n">disc_form</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">()))</span>
        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">disc_form</span><span class="p">)</span></div></div>


<span class="c1"># --- Integration Methods with dependencies between different equations ---</span>

<div class="viewcode-block" id="MultiDependencyTimeIntegratorUnit"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.MultiDependencyTimeIntegratorUnit">[docs]</a><span class="k">class</span> <span class="nc">MultiDependencyTimeIntegratorUnit</span><span class="p">(</span><span class="n">TimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base template class for integration methods that heavily depend on multiple equations of the ODE. Instances of these class have a variable called terms, which stores all equations</span>
<span class="sd">    the integration needs, due to dependency. The variable ``lhs_list`` stores the variables of the left hand sides of the original ODE (i.e. u(t)/dt) corresponding to the order of the equations in self.terms.</span>
<span class="sd">    The time_tendencies function has to be rewritten, to be able to index the right term.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MultiDependencyTimeIntegratorUnit.__init__"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.MultiDependencyTimeIntegratorUnit.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">terms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">terms</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="c1"># deltaT is an instance variable, so that TimeIntegratorUnits can be created for variable timestep length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;deltaT&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDependencyTimeIntegratorUnit.get_lhs_var"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.MultiDependencyTimeIntegratorUnit.get_lhs_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_lhs_var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lhs-var in the form x_i(t).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="MultiDependencyTimeIntegratorUnit.time_tendencies"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.MultiDependencyTimeIntegratorUnit.time_tendencies">[docs]</a>    <span class="k">def</span> <span class="nf">time_tendencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">termnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Example:</span>
<span class="sd">        lambda1 * u(t) + 2      --&gt;     lambda1 * u_n + 2</span>

<span class="sd">        Returns:</span>
<span class="sd">            The time_tendencies of ``self.term``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a copy of @self.term</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">termnum</span><span class="p">]</span>

        <span class="c1"># Substitute every symbol in equation_rhs with the corresponding timestepspecific symbol and update @timestep_specific_variables correspondingly</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">curr_tsv</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">curr_tsv</span><span class="p">)</span>

        <span class="c1"># Substitute possible occurrences of t</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">))</span>

        <span class="c1"># return the time_tendencies</span>
        <span class="k">return</span> <span class="n">term</span></div></div>


<div class="viewcode-block" id="Heun"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.Heun">[docs]</a><span class="k">class</span> <span class="nc">Heun</span><span class="p">(</span><span class="n">MultiDependencyTimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Heun&#39;s Method is a two-stage second order Runge Kutta method, which is often referred to as the improved Euler&#39;s method.</span>
<span class="sd">    It should always hold, that Midpoint.adapt_term == RungeKutta.adapt_term, when RungeKutta is called with the following Butcher Tableau::</span>

<span class="sd">     0</span>
<span class="sd">     1  1</span>
<span class="sd">     -  1/2  1/2</span>

<span class="sd">    Its general solution is as follows:</span>
<span class="sd">    ỹ_nplus1 = y_n + deltaT * f(t_n, y_n)</span>
<span class="sd">    y_nplus1 = y_n + deltaT/2 *(f(t_n,y_n) + f(t_nplus1, ỹ_nplus1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="Heun.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.Heun.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">lhs_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lhs_var</span><span class="p">()</span>

        <span class="c1"># get the first order time_tendencies for the term to integrate (terms index 0)</span>
        <span class="n">fi_ord_timetend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">t_n</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">)</span>
        <span class="n">sub_dict_builder</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">)):</span>
            <span class="n">curr_timetend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">curr_var_n</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">curr_var_tilde_nplus1</span> <span class="o">=</span> <span class="n">curr_var_n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">curr_timetend</span>
            <span class="n">sub_dict_builder</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">curr_var_n</span><span class="p">,</span> <span class="n">curr_var_tilde_nplus1</span><span class="p">)]</span>
        <span class="n">sub_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sub_dict_builder</span><span class="p">)</span>

        <span class="n">tilde_timetend</span> <span class="o">=</span> <span class="n">fi_ord_timetend</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_dict</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_nplus1</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">fi_ord_timetend</span> <span class="o">+</span> <span class="n">tilde_timetend</span><span class="p">)</span>

        <span class="n">disc_form</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">),</span> <span class="n">y_nplus1</span><span class="p">)</span>
        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">disc_form</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RungeKutta"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta">[docs]</a><span class="k">class</span> <span class="nc">RungeKutta</span><span class="p">(</span><span class="n">MultiDependencyTimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runge Kutta is a class of integration methods, whose members are all of form:</span>
<span class="sd">    :math:`y_{n+1} = y_n + dT * Σ b_i*k_i`</span>
<span class="sd">    with :math:`k_i = f(t_n + c_i * dT, y_n + a_ii * k_i-1)`.</span>
<span class="sd">    A Butcher Table, can be created for each specific Runge Kutta, which has the form::</span>

<span class="sd">     0</span>
<span class="sd">     c_2    a_21</span>
<span class="sd">     c_3    a_31    a_32</span>
<span class="sd">     ...    ...     ...     ...</span>
<span class="sd">     c_s    a_s1    a_s2    ...     a_s,s-1</span>
<span class="sd">      -     b_1     b_2     ...     b_s-1   b_s</span>

<span class="sd">    This class only represents explicit Runge Kutta methods, which implies, that the Butcher Tableau is a strict lower tridiagonal matrix.</span>
<span class="sd">    Note that this class is not intended to be instantiated. Instead create object off subclasses and use the compute_stages</span>
<span class="sd">    method to get a discrete form depending on a butcher tableau.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RungeKutta.compute_stages"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta.compute_stages">[docs]</a>    <span class="k">def</span> <span class="nf">compute_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">,</span> <span class="n">butcher_tab</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            butcher_tab: The Butcher-Tableau defining the member of the Runge-Kutta class. This should be a tuple containing</span>
<span class="sd">                three lists, that define vector c, matrix A and vector b respectively.</span>
<span class="sd">            dist_code: A distinct String, which defines the member of the Runge-Kutta class, that is used. This is important,</span>
<span class="sd">                to not confuse the Runge-Kutta Stages of different butcher-Tableaus.</span>

<span class="sd">        This method will append every RungeKutta Stage of every equation in ``self.terms`` to the ``TIES`` object. It</span>
<span class="sd">        will also append the equation describing the integrated form of ``y_nplus1``, where ``y_nplus1`` is correspondig to the</span>
<span class="sd">        variable at ``self.lhs_list[0]``. On the opposite to earlier versions of this function, the RungeKutta Stages will</span>
<span class="sd">        not be inserted into each higher Stage and thus save memory space as each Stage will now appear only once as a</span>
<span class="sd">        symbolic term.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lhs_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lhs_var</span><span class="p">()</span>

        <span class="c1"># Lists to represent the Butcher Tableau</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">butcher_tab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">butcher_tab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">butcher_tab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Matrix to save the Runge_Kutta_Stages for each equation in self.term</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">))]</span>
        <span class="c1"># Matrix that maps symbols of form x_i_rungekutta_j to k[i][j], which corresponds to the j-th RungeKutta Stage of equation i in self.terms</span>
        <span class="n">k_symbols</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">))]</span>

        <span class="n">t_n</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">)</span>

        <span class="c1"># Caluclation of every Runge_Kutta_Stage for every equation in self.terms</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
            <span class="c1"># Update the k_symbols matrix</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">)):</span>
                <span class="n">k_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">_S</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">,</span> <span class="n">i</span><span class="p">))]</span>

            <span class="c1"># Fill the k matrix with the next RungeKutta Stage from the TIES, if they have already been calculated for the discretization of another equation</span>
            <span class="n">k_symbols_at_stage_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k_symbols</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">curr_disc_eq</span> <span class="ow">in</span> <span class="n">ties</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">curr_disc_eq</span><span class="o">.</span><span class="n">lhs</span> <span class="ow">in</span> <span class="n">k_symbols_at_stage_i</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">k_symbols_at_stage_i</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">curr_disc_eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_disc_eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">]</span>

            <span class="c1"># Prepare the substitution of t_n with t_n + c_i*deltaT</span>
            <span class="n">sub_dict_builder</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span><span class="p">)]</span>

            <span class="c1"># Iterate over the elements of lhs_list(self.terms) to find out what to substitute for the RungeKutta Stage i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">)):</span>
                <span class="c1"># The variable to substitute</span>
                <span class="n">var_to_sub</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="c1"># new entry in the sub_dictionary for every x_j to substitute with x_j + deltaT * a_sum</span>
                <span class="n">a_sum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">a_sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">k_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">sub_dict_builder</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_to_sub</span><span class="p">,</span> <span class="n">var_to_sub</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">a_sum</span><span class="p">)]</span>

            <span class="n">sub_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sub_dict_builder</span><span class="p">)</span>

            <span class="c1"># Iterate over the elements of lhs_list (self.terms) to build the RungeKutta Stage i of every equation in self.terms</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">)):</span>
                <span class="c1"># Check if RungeKutta Stage ahs already been computed and thus already been added</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Build the Runge_Kutta_Stage_i for the equation of self.terms[j] (corresponding to lhs_list[j])</span>
                    <span class="c1"># Update matrix k correspondingly</span>
                    <span class="n">curr_rungekutta_stage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">curr_rungekutta_stage</span> <span class="o">=</span> <span class="n">curr_rungekutta_stage</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_dict</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_rungekutta_stage</span><span class="p">]</span>
                    <span class="c1"># Append the RungeKutta Stage to the TIES</span>
                    <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">k_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Create the equation to compute x_i_nplus1 for the variable at self.lhs_list[0]</span>
        <span class="c1"># y_n + deltaT * Σ b_i*k_symbols_i</span>
        <span class="c1"># b_sum = deltaT * Σ b_i*k_symbols_i</span>
        <span class="n">b_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">k_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">y_nplus1</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">b_sum</span>

        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">),</span> <span class="n">y_nplus1</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RungeKutta1"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta1">[docs]</a><span class="k">class</span> <span class="nc">RungeKutta1</span><span class="p">(</span><span class="n">RungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class implements the famous RK4 algorithm. The corresponding Butcher-Tableau is as follows::</span>

<span class="sd">         0</span>
<span class="sd">         -  1</span>

<span class="sd">        It must hold, that RungeKutta1 == ExplicitEuler, after inserting the first stage into the final term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="RungeKutta1.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta1.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;RK1&quot;</span>
        <span class="c1"># order 4 - classic Runge-Kutta</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RungeKutta2"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta2">[docs]</a><span class="k">class</span> <span class="nc">RungeKutta2</span><span class="p">(</span><span class="n">RungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class implements the famous RK4 algorithm. The corresponding Butcher-Tableau is as follows::</span>

<span class="sd">         0</span>
<span class="sd">         1/2    1/2</span>
<span class="sd">         -      0       1</span>

<span class="sd">        It must hold, that RungeKutta2 == Midpoint, after inserting the stages into the final term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">3</span>

<div class="viewcode-block" id="RungeKutta2.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta2.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;RK2&quot;</span>
        <span class="c1"># order 4 - classic Runge-Kutta</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RungeKutta4"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta4">[docs]</a><span class="k">class</span> <span class="nc">RungeKutta4</span><span class="p">(</span><span class="n">RungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements the famous RK4 algorithm. The corresponding Butcher-Tableau is as follows ::</span>

<span class="sd">     0</span>
<span class="sd">     1/2    1/2</span>
<span class="sd">     1/2    0       1/2</span>
<span class="sd">     1      0       0       1</span>
<span class="sd">     -      1/6     1/3     1/3     1/6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">5</span>

<div class="viewcode-block" id="RungeKutta4.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.RungeKutta4.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;RK4&quot;</span>
        <span class="c1"># order 4 - classic Runge-Kutta</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Midpoint"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.Midpoint">[docs]</a><span class="k">class</span> <span class="nc">Midpoint</span><span class="p">(</span><span class="n">MultiDependencyTimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The midpoint method is a second-order one-step method from the class of RungeKutta methods.</span>
<span class="sd">    The difference to the explicit Euler is in the slope, which is the tangent to the original function at the point</span>
<span class="sd">    in the middle between t and t+1.</span>
<span class="sd">    It should always hold, that Midpoint.adapt_term == RungeKutta.adapt_term, when RungeKutta is called with the following</span>
<span class="sd">    Butcher Tableau::</span>

<span class="sd">     0</span>
<span class="sd">     1/2  1/2</span>
<span class="sd">     -     0    1</span>

<span class="sd">    The general midpoint method to a problem of the form :math:`y&#39;(t) = f(t,y(t))` is the following:</span>
<span class="sd">    :math:`y_{n+1} = y_n + dt*f(t+ dt/2 , y_n + (dt/2) * f(t, y_n))`</span>


<span class="sd">    Source:</span>
<span class="sd">        John Burkhardt, Florida State University : Introduction to Scientific Computing with C++, 2011 SS, Lecture 19, Slide 10</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="Midpoint.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.Midpoint.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">lhs_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lhs_var</span><span class="p">()</span>

        <span class="c1"># get the first order time_tendencies for the term to integrate (terms index 0)</span>
        <span class="n">fi_ord_timetend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">t_n</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">)</span>
        <span class="n">sub_dict_builder</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">)):</span>
            <span class="c1"># get the first order time_tendencies for the term to integrate (terms index 0)</span>
            <span class="n">curr_timetend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_tendencies</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">var_to_sub</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">sub_dict_builder</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_to_sub</span><span class="p">,</span> <span class="n">var_to_sub</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr_timetend</span><span class="p">)]</span>
        <span class="n">sub_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sub_dict_builder</span><span class="p">)</span>

        <span class="n">sec_ord_timetend</span> <span class="o">=</span> <span class="n">fi_ord_timetend</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_dict</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">disc_form</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">),</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_var</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">sec_ord_timetend</span><span class="p">)</span>
        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">disc_form</span><span class="p">)</span></div></div>


<span class="c1"># --- Splitting Techniques ---</span>

<div class="viewcode-block" id="OperatorSplitting"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.OperatorSplitting">[docs]</a><span class="k">class</span> <span class="nc">OperatorSplitting</span><span class="p">(</span><span class="n">TimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class for most splitting techniques. Other than TimeIntegratorUnits, splitting techniques consist of two terms, that are already annotated with a</span>
<span class="sd">    specific time integration method.</span>
<span class="sd">    The ``resolve()`` and ``adapt_term()`` structure is still the same as in TimeIntegratorUnit</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorSplitting.__init__"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.OperatorSplitting.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annot_list</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This init is oriented to ``__init__`` of ``TimeIntegratorUnit``. ``annot1`` and ``annot2`` are typically the two TimeIntegratorAnnotatedODEs (according to the operators in the original system),</span>
<span class="sd">        which will now be put together according to the Splitting method.</span>
<span class="sd">        ``param`` annot_list must be an iterable consisting of exactly two TimeIntegratorAnnotatedODE objects, representing the two operators of the original system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annot1</span> <span class="o">=</span> <span class="n">annot_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annot2</span> <span class="o">=</span> <span class="n">annot_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="c1"># deltaT is an instance variable, so that TimeIntegratorUnits can be created for variable timestep length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;deltaT&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OrdinarySplitting"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.OrdinarySplitting">[docs]</a><span class="k">class</span> <span class="nc">OrdinarySplitting</span><span class="p">(</span><span class="n">OperatorSplitting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ordinary splitting integrates the two operators each for one timestep length deltaT, while the result of the</span>
<span class="sd">    integration of the first operator is used as input value for the second operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="OrdinarySplitting.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.OrdinarySplitting.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>

        <span class="c1"># Create the discrete equations of the split systems</span>
        <span class="n">split_ties1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot1</span><span class="o">.</span><span class="n">transform_TIES</span><span class="p">()</span>
        <span class="n">split_ties2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot2</span><span class="o">.</span><span class="n">transform_TIES</span><span class="p">()</span>

        <span class="c1"># Substitute discrete variables correspondingly</span>
        <span class="n">var_n_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_nplus1_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_tilde_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">var_n_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span>
            <span class="n">var_nplus1_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span>
            <span class="n">var_tilde_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_tilde&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">func</span><span class="p">))]</span>

        <span class="c1"># Build substitution dictionary for the first ties ( x_nplus1 -&gt; x_tilde )</span>
        <span class="n">subs_dict_builder1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_nplus1_list</span><span class="p">)):</span>
            <span class="n">subs_dict_builder1</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_nplus1_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_tilde_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">subs_dict1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subs_dict_builder1</span><span class="p">)</span>

        <span class="c1"># Build substitution dictionary for the second ties ( x_n -&gt; x_tilde)</span>
        <span class="n">subs_dict_builder2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_n_list</span><span class="p">)):</span>
            <span class="n">subs_dict_builder2</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_n_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_tilde_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">subs_dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subs_dict_builder2</span><span class="p">)</span>

        <span class="c1"># Substitute ties1 according to subs_dict1 and ties2 according to subs_dict2 and append them to the ties</span>
        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="n">split_ties1</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict_builder1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="n">split_ties2</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict_builder2</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="StrangSplitting"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.StrangSplitting">[docs]</a><span class="k">class</span> <span class="nc">StrangSplitting</span><span class="p">(</span><span class="n">OperatorSplitting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Strang splitting is used to divide an equation consisting of an addition of two terms, which are mostly not stable to the same integration method. Thus both terms are treated seperately.</span>
<span class="sd">    If the first term gets integrated for deltaT/2, then used as initialvalue for integrating the second term for deltaT, which then again is used to integrate the first term for deltaT/2, the error</span>
<span class="sd">    this method induces is only of second order.</span>

<span class="sd">    Example:</span>
<span class="sd">        Equation:</span>
<span class="sd">         :math:`u_t = λ_1 u + λ_2 u`</span>

<span class="sd">        Split into TimeIntegratorUnits:</span>
<span class="sd">         | → tiu1 = ExplicitEuler(:math:`λ_1 u`)</span>
<span class="sd">         | → tiu2 = ExplicitEuler(:math:`λ_2 u)`</span>

<span class="sd">        Discretized Equations (h⁼dT):</span>
<span class="sd">         | :math:`v = u_n + h / 2 * (λ_1 u_n)`</span>
<span class="sd">         | :math:`w = v + h * (λ_2 v)`</span>
<span class="sd">         | :math:`u_{n+1} = w + h/2 * (λ_1 w)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_eqs_added</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="StrangSplitting.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.StrangSplitting.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="c1"># Example:</span>
        <span class="c1"># u_t = lambda1 * u + lambda2 * u</span>
        <span class="c1"># -&gt; tiu1 = ExplicitEuler(lambda1 * u)</span>
        <span class="c1"># -&gt; tiu2 = ExplicitEuler(lambda2 * u)</span>
        <span class="c1"># ũ = u_n + deltaT / 2 * (lambda1 * u_n)</span>
        <span class="c1"># ū = ũ + deltaT * (lambda2 * ũ)</span>
        <span class="c1"># u_nplus1 = ū + deltaT / 2 * (lambda1 * ū)</span>

        <span class="c1"># Set the timestep length deltaT to 1/2 for the first and third fractional step</span>
        <span class="k">for</span> <span class="n">curr_tiu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot1</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">curr_tiu</span><span class="o">.</span><span class="n">set_deltaT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Create the three discrete systems according to the composition of the Strang Splitting method</span>
        <span class="c1"># First fractional step</span>
        <span class="n">split_ties1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot1</span><span class="o">.</span><span class="n">transform_TIES</span><span class="p">()</span>
        <span class="c1"># second fractional step</span>
        <span class="n">split_ties2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot2</span><span class="o">.</span><span class="n">transform_TIES</span><span class="p">()</span>
        <span class="c1"># third fractional step</span>
        <span class="n">split_ties3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot1</span><span class="o">.</span><span class="n">transform_TIES</span><span class="p">()</span>

        <span class="c1"># Substitute the discrete variables correspondingly to x_i_tilde and x_i_bar</span>
        <span class="n">var_n_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_nplus1_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_tilde_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_bar_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">var_n_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span>
            <span class="n">var_nplus1_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span>
            <span class="n">var_tilde_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_tilde&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">func</span><span class="p">))]</span>
            <span class="n">var_bar_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_bar&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">func</span><span class="p">))]</span>

        <span class="c1"># Build the substitution dictionary for the first TIES ( x_nplus1 -&gt; x_tilde )</span>
        <span class="n">subs_dict_builder1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_nplus1_list</span><span class="p">)):</span>
            <span class="n">subs_dict_builder1</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_nplus1_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_tilde_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">subs_dict1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subs_dict_builder1</span><span class="p">)</span>

        <span class="c1"># Build the substitution dictionary fo the second TIES ( x_n -&gt; x_tilde, x_nplus1 -&gt; x_bar)</span>
        <span class="n">subs_dict_builder2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_n_list</span><span class="p">)):</span>
            <span class="n">subs_dict_builder2</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_n_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_tilde_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="n">subs_dict_builder2</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_nplus1_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_bar_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">subs_dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subs_dict_builder2</span><span class="p">)</span>

        <span class="c1"># Build the substitution dictionary fo the second TIES ( x_n -&gt;  x_bar)</span>
        <span class="n">subs_dict_builder3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_n_list</span><span class="p">)):</span>
            <span class="n">subs_dict_builder3</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">var_n_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var_bar_list</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
        <span class="n">subs_dict3</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subs_dict_builder3</span><span class="p">)</span>

        <span class="c1"># Substitute ties1 according to subs_dict1, ties2 according to subs_dict2 and ties3 according to subs_dict3,</span>
        <span class="c1"># and append them to the ties</span>
        <span class="c1"># First fractional step</span>
        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="n">split_ties1</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict_builder1</span><span class="p">))</span>

        <span class="c1"># Second fractional step</span>
        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="n">split_ties2</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict_builder2</span><span class="p">))</span>

        <span class="c1"># Third fractional step</span>
        <span class="k">for</span> <span class="n">curr_eq</span> <span class="ow">in</span> <span class="n">split_ties3</span><span class="o">.</span><span class="n">get_equations</span><span class="p">():</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">curr_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_dict_builder3</span><span class="p">))</span></div></div>


<span class="c1"># --- Integration Methods with dependencies between different equations ---</span>

<div class="viewcode-block" id="DependentSystemTimeIntegratorUnit"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DependentSystemTimeIntegratorUnit">[docs]</a><span class="k">class</span> <span class="nc">DependentSystemTimeIntegratorUnit</span><span class="p">(</span><span class="n">TimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base template class for integration methods that heavily depend on multiple equations of the ODE. Instances of these class have a variable called terms, which stores all equations</span>
<span class="sd">    the integration needs, due to dependency. The variable ``lhs_list`` stores the variables of the left hand sides of the original ODE (i.e. u(t)/dt) corresponding to the order of the equations in self.terms.</span>
<span class="sd">    The function ``time_tendencies`` has to be rewritten, to be able to index the right term.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DependentSystemTimeIntegratorUnit.__init__"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DependentSystemTimeIntegratorUnit.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base Constructor for DependentSystemTimeIntegratorUnit instances.</span>

<span class="sd">        Args:</span>
<span class="sd">            terms (tuple of sympy.core.relational.Equality):</span>
<span class="sd">            variables (tuple of sympy.core.symbol.Symbol):</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">terms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">terms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_condition</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;iteration_condition&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="c1"># deltaT is an instance variable, so that TimeIntegratorUnits can be created for variable timestep length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;deltaT&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DependentSystemTimeIntegratorUnit.get_additional_config_variables"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DependentSystemTimeIntegratorUnit.get_additional_config_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_additional_config_variables</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">add_vars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;iterative_method&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">add_vars</span></div>

<div class="viewcode-block" id="DependentSystemTimeIntegratorUnit.get_lhs_var"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DependentSystemTimeIntegratorUnit.get_lhs_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_lhs_var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lhs-var in the form x_i(t).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="DependentSystemTimeIntegratorUnit.time_tendencies"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DependentSystemTimeIntegratorUnit.time_tendencies">[docs]</a>    <span class="k">def</span> <span class="nf">time_tendencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">termnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the time_tendencies of ``self.terms[termnum]``.</span>

<span class="sd">        Example:</span>
<span class="sd">            For the term lambda1 * u(t) + 2 this returns lambda1 * u_n + 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a copy of self.term</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">termnum</span><span class="p">]</span>

        <span class="c1"># Substitute every symbol in equation_rhs with the corresponding timestepspecific symbol and update @timestep_specific_variables correspondingly</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">curr_tsv</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">curr_tsv</span><span class="p">)</span>

        <span class="c1"># Substitute possible occurrences of t</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;t_n&quot;</span><span class="p">))</span>

        <span class="c1"># return the time_tendencies</span>
        <span class="k">return</span> <span class="n">term</span></div></div>


<div class="viewcode-block" id="BackwardEuler"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardEuler">[docs]</a><span class="k">class</span> <span class="nc">BackwardEuler</span><span class="p">(</span><span class="n">DependentSystemTimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic implementation of the Backwards/Implicit Euler method:</span>

<span class="sd">    :math:`t_{n+1} = t_n + dT` and</span>
<span class="sd">    :math:`x_{n+1}= x_n + dT * f(t_{n+1}, x_{n+1})`</span>

<span class="sd">    To approximate a solution :math:`x_{n+1}`, Newton&#39;s method is used:</span>

<span class="sd">    :math:`y_{i+1} = y_i - g(y_i)/g&#39;(y_i)`</span>

<span class="sd">    Combining those, the algorithm generates the value at the next time step through iteration of the following formula</span>
<span class="sd">    until convergence:</span>

<span class="sd">    :math:`y_{i+1} = y_i - (y_i - x_n - dT * f(t_{n+1}, y_n)) / (1 - dT * d/dt f(t_{n+1}, y_n))`</span>

<span class="sd">    The Backwards Euler Method can be seen as a first order single stage order Runge Kutta method</span>
<span class="sd">    with the following Butcher Tableau:</span>

<span class="sd">    |   1   1</span>
<span class="sd">    |   1</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BackwardEuler.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardEuler.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">lhs_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">guesses</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">g_i</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_i&quot;</span><span class="p">)</span>
            <span class="n">g_i_1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_iplus1&quot;</span><span class="p">)</span>
            <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_i</span><span class="p">)</span>
            <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_i_1</span><span class="p">)</span>

        <span class="c1"># Backwards Euler scheme as a function we can find x_n+1 as the root</span>
        <span class="c1"># x_i_n+1 - x_i - dt*f(x_i) = 0</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># Make Jacobi Matrix</span>
        <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">J_i</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">dfdx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">J_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dfdx</span><span class="p">)</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_i</span><span class="p">)</span>
        <span class="n">Jacobi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">inverse_LU</span><span class="p">()</span>

        <span class="c1"># Make step functions</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">Jacobi</span> <span class="o">*</span> <span class="n">f</span>

        <span class="nb">next</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">sub</span><span class="p">)</span>

        <span class="n">difference</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">difference</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">g_step_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize g_i_1 with first approximation of next value (forward Euler step)</span>
        <span class="c1"># g_i with a value more than error higher</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">g_i</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_i&quot;</span><span class="p">)</span>
            <span class="n">g_i_1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_iplus1&quot;</span><span class="p">)</span>
            <span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_i</span><span class="p">)</span>
            <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_i_1</span><span class="p">)</span>
            <span class="n">g_init1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">g_init2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>
            <span class="n">g_step</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">g_init1</span><span class="p">)</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">g_init2</span><span class="p">)</span>
            <span class="n">g_step_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_step</span><span class="p">)</span>

        <span class="n">flat_lhs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="nb">next</span><span class="o">.</span><span class="n">lhs</span><span class="p">))</span>
        <span class="n">flat_rhs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="nb">next</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span>
        <span class="n">newton_step</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_lhs</span><span class="p">)):</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">flat_lhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">flat_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">newton_step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>


        <span class="c1"># Newton iteration while loop</span>
        <span class="kn">from</span> <span class="nn">sympy.codegen.ast</span> <span class="k">import</span> <span class="n">While</span>
        <span class="n">whl</span> <span class="o">=</span> <span class="n">While</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_condition</span><span class="p">,</span>
                    <span class="n">g_step_list</span> <span class="o">+</span> <span class="n">newton_step</span><span class="p">)</span>

        <span class="c1"># ties.app(initialize_error)</span>
        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">whl</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">fa</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BackwardRungeKutta"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta">[docs]</a><span class="k">class</span> <span class="nc">BackwardRungeKutta</span><span class="p">(</span><span class="n">DependentSystemTimeIntegratorUnit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class only represents implicit Runge Kutta methods. For explicit methods use the RungeKutta class.</span>

<span class="sd">    Note:</span>
<span class="sd">        This class is not intended to be instantiated. Instead create object off subclasses and use the compute_stages</span>
<span class="sd">        method to get a discrete form depending on a butcher tableau.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># @property</span>
<div class="viewcode-block" id="BackwardRungeKutta.substitute_at_end"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta.substitute_at_end">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_at_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="BackwardRungeKutta.compute_stages"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta.compute_stages">[docs]</a>    <span class="k">def</span> <span class="nf">compute_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">,</span> <span class="n">butcher_tab</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            butcher_tab: The Butcher-Tableau defining the member of the Runge-Kutta class. This should be a tuple containing</span>
<span class="sd">                three lists, that define vector c, matrix A and vector b respectively.</span>
<span class="sd">            dist_code: A distinct String, which defines the member of the Runge-Kutta class, that is used. This is important,</span>
<span class="sd">                to not confuse the Runge-Kutta Stages of different butcher-Tableaus.</span>

<span class="sd">        This method will append every RungeKutta Stage of every equation in self.terms to the TIES object. It</span>
<span class="sd">        will also append the equation describing the integrated form of y_nplus1, where y_nplus1 is correspondig to the</span>
<span class="sd">        variable at ``self.lhs_list[0]``. On the opposite to earlier versions of this function, the RungeKutta Stages will</span>
<span class="sd">        not be inserted into each higher Stage and thus save memory space as each Stage will now appear only once as a</span>
<span class="sd">        symbolic term.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Lists to represent the Butcher Tableau</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">butcher_tab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">butcher_tab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">num_equations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">num_stages</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_equations</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inv_A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">inverse_LU</span><span class="p">()</span>
        <span class="n">lambda_list</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inv_A</span><span class="o">.</span><span class="n">jordan_form</span><span class="p">()</span>
        <span class="n">T</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="n">inv_T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">inverse_LU</span><span class="p">()</span>
        <span class="n">inv_T</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="n">Q</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">inv_T</span>
        <span class="n">PQ</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">Q</span>
        <span class="n">PQ</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="n">PxI</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">KroneckerProduct</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
        <span class="n">QxI</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">KroneckerProduct</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>

        <span class="c1"># TODO does superdiagonal==1 or subdiagonal==1 make sense here?</span>
        <span class="n">epsilon_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">PQ</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">PQ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">epsilon_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>

        <span class="n">x_n_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">))</span>
        <span class="n">last_state</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">x_n_list</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">runge_kutta_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">stage_symbols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
                <span class="n">new_symbol</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">_RK</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">stage_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_symbol</span><span class="p">)</span>
                <span class="n">initialize_symbol</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">new_symbol</span><span class="p">,</span> <span class="n">x_n_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="c1"># a = list(map(lambda a: dsc.var_with_n(a), self.lhs_list))</span>
                <span class="c1"># df = self.terms[j].subs(zip(self.lhs_list, a))</span>
                <span class="c1"># initialize_symbol = sp.Eq(new_symbol, x_n_list[j] + self.deltaT * df)</span>
                <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">initialize_symbol</span><span class="p">)</span>
            <span class="n">runge_kutta_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stage_symbols</span><span class="p">)</span>

        <span class="n">runge_kutta_temp_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">stage_symbols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
                <span class="n">new_symbol</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;tx_</span><span class="si">%s</span><span class="s2">_RK</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">stage_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_symbol</span><span class="p">)</span>
            <span class="n">runge_kutta_temp_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stage_symbols</span><span class="p">)</span>

        <span class="n">runge_kutta_temp_symbols2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
            <span class="n">new_symbol</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;tx_</span><span class="si">%s</span><span class="s2">_RK&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">runge_kutta_temp_symbols2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_symbol</span><span class="p">)</span>

        <span class="c1"># Make Jacobi Matrix</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_Jacobi_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">J</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">last_state</span><span class="p">,</span> <span class="n">runge_kutta_temp_symbols2</span><span class="p">)))</span>

        <span class="n">diagonal_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lambda_list</span><span class="p">:</span>
            <span class="c1"># multiplicity!</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lambda_list</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">I</span> <span class="o">-</span> <span class="n">l</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">J</span>
                <span class="n">diagonal_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">epsilon_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epsilon_list</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">I</span>
            <span class="n">epsilon_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">system_rank</span> <span class="o">=</span> <span class="n">num_stages</span> <span class="o">*</span> <span class="n">num_equations</span>
        <span class="n">M_tilde</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">diagonal_block</span> <span class="o">=</span> <span class="n">diagonal_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subdiagonal_block</span> <span class="o">=</span> <span class="n">epsilon_blocks</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_equations</span><span class="p">,</span> <span class="n">num_equations</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdiagonal_block</span><span class="p">)</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diagonal_block</span><span class="p">)</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_equations</span><span class="p">,</span> <span class="n">system_rank</span> <span class="o">-</span> <span class="n">num_equations</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diagonal_block</span><span class="p">)</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_equations</span><span class="p">,</span> <span class="n">system_rank</span> <span class="o">-</span> <span class="n">num_equations</span><span class="p">)))</span>
            <span class="n">M_tilde</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="n">M_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">M_tilde</span><span class="p">)</span>
        <span class="n">M_tilde</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">M_tilde</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">M_tilde</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="n">equations_for_rk_stages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">rk_stage_symbols</span> <span class="o">=</span> <span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">substituted_equations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">rk_stage_symbols</span><span class="p">))</span>
                <span class="n">equation</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="n">substituted_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span>
            <span class="n">equations_for_rk_stages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">substituted_equations</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Zi = -Yi + y_m-1 + h * sum(over stages_j)(aij * f(Yj)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">Y_i</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Z_i</span> <span class="o">=</span> <span class="o">-</span> <span class="n">Y_i</span> <span class="o">+</span> <span class="n">last_state</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
                <span class="n">Z_i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">equations_for_rk_stages</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">Z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Z_i</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Z</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="n">Z_tilde</span> <span class="o">=</span> <span class="n">PxI</span> <span class="o">*</span> <span class="n">Z</span>
        <span class="n">Z_tilde</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">runge_kutta_symbols</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">w_tilde</span> <span class="o">=</span> <span class="n">M_tilde</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">Z_tilde</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">QxI</span> <span class="o">*</span> <span class="n">w_tilde</span>

        <span class="n">Y_new</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">+</span> <span class="n">w</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_stages</span><span class="p">,</span> <span class="n">num_equations</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">Y_new</span> <span class="o">=</span> <span class="n">Y_new</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>

        <span class="c1"># step Schritte</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
                <span class="n">Yi</span> <span class="o">=</span> <span class="n">Y_new</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">Yi</span> <span class="o">=</span> <span class="n">Yi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">runge_kutta_temp_symbols2</span><span class="p">,</span> <span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">])))</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">runge_kutta_temp_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">Yi</span><span class="p">)</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substitute_at_end</span><span class="p">())</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span>

        <span class="c1"># Calculate difference between last and new iteration</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">runge_kutta_temp_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span>
        <span class="c1"># error = sp.sqrt(error)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

        <span class="c1"># step Schritte</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">runge_kutta_temp_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substitute_at_end</span><span class="p">())</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span>

        <span class="c1"># Final assignment</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_stages</span><span class="p">):</span>
            <span class="n">rk</span> <span class="o">=</span> <span class="n">runge_kutta_symbols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">eq</span><span class="p">]</span>
                <span class="n">fYj</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">rk</span><span class="p">))</span>
                <span class="n">fYj</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaT</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">fYj</span>
                <span class="n">step</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">step</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substitute_at_end</span><span class="p">())</span>
                <span class="n">last_state</span><span class="p">[</span><span class="n">eq</span><span class="p">]</span> <span class="o">+=</span> <span class="n">step</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>

        <span class="c1"># Newton iteration while loop</span>
        <span class="kn">from</span> <span class="nn">sympy.codegen.ast</span> <span class="k">import</span> <span class="n">While</span>
        <span class="n">whl</span> <span class="o">=</span> <span class="n">While</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_condition</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

        <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">whl</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_equations</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_nplus1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">[</span><span class="n">eq</span><span class="p">])</span>
            <span class="n">equation</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">last_state</span><span class="p">[</span><span class="n">eq</span><span class="p">])</span>
            <span class="n">equation</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substitute_at_end</span><span class="p">())</span>
            <span class="n">ties</span><span class="o">.</span><span class="n">app</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span></div>

<div class="viewcode-block" id="BackwardRungeKutta.make_Jacobi_matrix"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta.make_Jacobi_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">make_Jacobi_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">J_i</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">dsc</span><span class="o">.</span><span class="n">var_with_n</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">))</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_list</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">dfdx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">J_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dfdx</span><span class="p">)</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_i</span><span class="p">)</span>
        <span class="n">Jacobi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Jacobi</span></div></div>

<div class="viewcode-block" id="BackwardRungeKutta1"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta1">[docs]</a><span class="k">class</span> <span class="nc">BackwardRungeKutta1</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The one stage Implicit Runge-Kutta method of order one is identical to the Backwards Euler Method</span>
<span class="sd">    and has with the following Butcher Tableau::</span>

<span class="sd">     1   1</span>
<span class="sd">     1</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BackwardRungeKutta1.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.BackwardRungeKutta1.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;BRK1&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="ImplicitMidpoint"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.ImplicitMidpoint">[docs]</a><span class="k">class</span> <span class="nc">ImplicitMidpoint</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     The Implicit Midpoint Method can be seen as a second order two stageRunge Kutta method with the following Butcher Tableau::</span>

<span class="sd">      1/2   1/2</span>
<span class="sd">       -    1</span>
<span class="sd">     &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ImplicitMidpoint.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.ImplicitMidpoint.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;IMP&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="DIRK2"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK2">[docs]</a><span class="k">class</span> <span class="nc">DIRK2</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     This Method is a Diagonally Implicit Runge Kutta method (2nd order, 2 stages) with the following Butcher Tableau::</span>

<span class="sd">      1/4   1/4</span>
<span class="sd">      3/4   1/2     1/4</span>
<span class="sd">       -    1/2     1/2</span>
<span class="sd">     &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DIRK2.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK2.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;DIRK2&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DIRK3"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK3">[docs]</a><span class="k">class</span> <span class="nc">DIRK3</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Method is a Diagonally Implicit Runge Kutta method (3nd order, 4 stages) with the following Butcher Tableau::</span>

<span class="sd">     1/2   1/2</span>
<span class="sd">     2/3   1/6      1/2</span>
<span class="sd">     1/2  -1/2      1/2    1/2</span>
<span class="sd">     1     3/2     -3/2    1/2     1/2</span>
<span class="sd">     -     3/2     -3/2    1/2     1/2</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DIRK3.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK3.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;DIRK3&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="GL4"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.GL4">[docs]</a><span class="k">class</span> <span class="nc">GL4</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This uses the Gauss–Legendre method of order four with two stages and the following Butcher Tableau::</span>

<span class="sd">     2-x    1/4     1/4-x</span>
<span class="sd">     2+x    1/4+x   1/4</span>
<span class="sd">     -      1/2     1/2</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GL4.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.GL4.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;GL4&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DIRK4"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK4">[docs]</a><span class="k">class</span> <span class="nc">DIRK4</span><span class="p">(</span><span class="n">BackwardRungeKutta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This uses a Diagonally Implicit Runge Kutta method (4th order, 3 stages) with the following Butcher Tableau::</span>

<span class="sd">     x      x</span>
<span class="sd">     1/2    1/2-x   x</span>
<span class="sd">     1-x    2x      1-4x    x</span>
<span class="sd">     -      b1      b2      b1</span>

<span class="sd">     with b1 = 1 / (6*(1-2*x)**2),  b2 = 1 - 1/(3*(1-2*x)**2)</span>
<span class="sd">     and x = any of {53429/50000, 60507/200000 or 64443/500000}</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DIRK4.substitute_at_end"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK4.substitute_at_end">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_at_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="mi">53429</span> <span class="o">/</span> <span class="mi">50000</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="mi">60507</span> <span class="o">/</span> <span class="mi">200000</span><span class="p">)</span>
        <span class="n">x3</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="mi">64443</span> <span class="o">/</span> <span class="mi">500000</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x3</span><span class="p">}</span></div>

<div class="viewcode-block" id="DIRK4.adapt_terms"><a class="viewcode-back" href="../TimeIntegratorUnit.html#TimeIntegratorUnit.DIRK4.adapt_terms">[docs]</a>    <span class="k">def</span> <span class="nf">adapt_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ties</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">b2</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">dist_code</span> <span class="o">=</span> <span class="s2">&quot;DIRK4&quot;</span>
        <span class="n">butcher</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_stages</span><span class="p">(</span><span class="n">ties</span><span class="p">,</span> <span class="n">butcher</span><span class="p">,</span> <span class="n">dist_code</span><span class="p">)</span></div></div>


<span class="c1"># --- METHOD DICTIONARY ---</span>

<span class="n">annotation_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ExplicitEuler&quot;</span>  <span class="p">:</span> <span class="n">ExplicitEuler</span><span class="p">,</span> <span class="s2">&quot;Heun&quot;</span><span class="p">:</span> <span class="n">Heun</span><span class="p">,</span> <span class="s2">&quot;RungeKutta4&quot;</span><span class="p">:</span> <span class="n">RungeKutta4</span><span class="p">,</span> <span class="s2">&quot;RK4&quot;</span><span class="p">:</span> <span class="n">RungeKutta4</span><span class="p">,</span>
                   <span class="s2">&quot;RungeKutta1&quot;</span>    <span class="p">:</span> <span class="n">RungeKutta1</span><span class="p">,</span> <span class="s2">&quot;RK1&quot;</span><span class="p">:</span> <span class="n">RungeKutta1</span><span class="p">,</span> <span class="s2">&quot;RungeKutta2&quot;</span><span class="p">:</span> <span class="n">RungeKutta2</span><span class="p">,</span> <span class="s2">&quot;RK2&quot;</span><span class="p">:</span> <span class="n">RungeKutta2</span><span class="p">,</span>
                   <span class="s2">&quot;Midpoint&quot;</span>       <span class="p">:</span> <span class="n">Midpoint</span><span class="p">,</span> <span class="s2">&quot;OrdinarySplitting&quot;</span><span class="p">:</span> <span class="n">OrdinarySplitting</span><span class="p">,</span>
                   <span class="s2">&quot;StrangSplitting&quot;</span><span class="p">:</span> <span class="n">StrangSplitting</span><span class="p">,</span> <span class="s2">&quot;BackwardEuler&quot;</span><span class="p">:</span> <span class="n">BackwardEuler</span><span class="p">,</span> <span class="s2">&quot;BRK1&quot;</span><span class="p">:</span> <span class="n">BackwardRungeKutta1</span><span class="p">,</span>
                   <span class="s2">&quot;IMP&quot;</span><span class="p">:</span> <span class="n">ImplicitMidpoint</span><span class="p">,</span> <span class="s2">&quot;DIRK2&quot;</span><span class="p">:</span> <span class="n">DIRK2</span><span class="p">,</span> <span class="s2">&quot;DIRK3&quot;</span><span class="p">:</span> <span class="n">DIRK3</span><span class="p">,</span> <span class="s2">&quot;DIRK4&quot;</span><span class="p">:</span> <span class="n">DIRK4</span><span class="p">,</span> <span class="s2">&quot;GL4&quot;</span><span class="p">:</span> <span class="n">GL4</span><span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``method_builder_dict`` is a dictionary connecting the names of each class in this file with an instantiation of that class. This is primarly used in ``EquationSystem.ODE``.</span>
<span class="sd">This dictionary has to be manually extended for each time integration method added.</span>
<span class="sd">&quot;&quot;&quot;</span>


</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Anna Mittermair

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>